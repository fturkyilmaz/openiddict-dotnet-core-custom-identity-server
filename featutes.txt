# OpenId flow design with refresh, grant types, consent, and client secrets

İyi ki söyledin Furkan. Aşağıda OpenIddict tabanlı tam akışı; Authorization Code + PKCE, Client Credentials, Refresh Token, Revoke ve Consent adımlarını netleştirdim. Her bir akışın endpoint’leri, veri modelleri, konfigürasyonu ve önerilen repository/service yapısı var. Sonunda hazır bir commit mesajı da ekledim.

---

## Grant types and endpoints

- **Authorization Code + PKCE (public SPA/native apps)**
  - **Endpoints:**
    - **GET /connect/authorize**: authorization request (scope, client_id, redirect_uri, response_type=code, code_challenge)
    - **POST /connect/token**: exchange code for tokens (code_verifier ile)
    - **POST /connect/revoke**: refresh token veya access token revoke
    - **GET /connect/userinfo**: user claims
  - **Scopes:** openid, profile, email, offline_access (+ domain-specific, e.g., products.read)
  - **Tokens:** access token, id token; offline_access varsa refresh token

- **Client Credentials (machine-to-machine)**
  - **Endpoint:** **POST /connect/token** (grant_type=client_credentials, client_id, client_secret)
  - **Scopes:** service-specific (e.g., audit.write, jobs.execute)
  - **Tokens:** access token (genelde kısa ömürlü)

- **Password (opsiyonel, sadece legacy veya admin tooling)**
  - **Endpoint:** **POST /connect/token** (grant_type=password)
  - Tavsiye: mümkünse kaldır, yerine Authorization Code + PKCE kullan

- **Refresh Token**
  - **Endpoint:** **POST /connect/token** (grant_type=refresh_token, refresh_token)
  - **Policy:** rotation, reuse detection, expiration, revocation

- **Revoke**
  - **Endpoint:** **POST /connect/revoke** (token, token_type_hint=refresh_token|access_token)
  - Refresh tokenları invalid etmek için kullan

---

## Consent and clients

#### Consent model
- **Consent**: user_id, client_id, scopes[], created_at, updated_at, revoked_at
- Kullanıcı authorize ekranında scope onayı verince kaydedilir. Tekrar istemez; yeni scope isterse re-consent gerekir.
- **Revocation:** kullanıcı veya admin panelinden consent’leri iptal edebilir; refresh tokenları da revoke edilir.

#### Clients
- **Client**: client_id, client_name, type (confidential|public), redirect_uris[], post_logout_redirect_uris[], grant_types[], scopes[], client_secret_hash, require_pkce (public için true)
- **Secret storage:** `client_secret_hash` (PasswordHasher veya Argon2/BCrypt). Asla düz metin yok.
- **Policies:**
  - Public clients: no secret, require PKCE, allowed grants: authorization_code
  - Confidential clients: require secret, allowed grants: client_credentials, authorization_code, refresh_token

---

## Backend configuration (OpenIddict)

#### Service registration (InfrastructureServiceExtensions)
- **OpenIddict server:**
  - Allowed flows: authorization_code, client_credentials, refresh_token
  - Token endpoint, authorization endpoint, revocation endpoint, userinfo endpoint active
  - PKCE required for public clients
  - Scopes: openid, profile, email, offline_access + custom
- **Validation:**
  - Introspection veya local validation (prefer local with signing keys)
- **Events (OpenIddictEvents):**
  - OnTokenIssuing: add domain claims, tenant, roles
  - OnValidateAuthorizationRequest: client/grant/scope validation
  - OnHandleRevocationRequest: refresh token cleanup
  - OnConsentRequired: redirect to consent page

---

## Controllers and request flows

#### AuthorizationController
- **GET /connect/authorize**
  - **Input:** client_id, redirect_uri, response_type=code, scope, state, code_challenge, code_challenge_method
  - **Flow:**
    1. Authenticate user (if not logged in → login page).
    2. Validate client and redirect_uri.
    3. Check existing consent for requested scopes.
    4. If consent missing → show consent UI (scopes list).
    5. Issue authorization code → redirect to redirect_uri with code+state.

- **POST /connect/token**
  - Authorization code:
    - Validate code_verifier (PKCE).
    - Issue access_token, id_token, refresh_token (if offline_access).
  - Client credentials:
    - Validate client_secret (confidential).
    - Issue access_token with requested scopes.
  - Refresh token:
    - Validate and rotate refresh token.
    - Issue new access_token (+ id_token optional), new refresh_token.

- **POST /connect/revoke**
  - Invalidate refresh or access tokens (prefer refresh).

- **GET /connect/userinfo**
  - Return normalized user claims (sub, name, email, roles).

#### ConsentController (opsiyonel, Web)
- **GET /consent**
  - Show scopes, client name, purpose; confirm/deny
- **POST /consent**
  - Save consent, continue authorize flow

#### ClientsController / UserController
- CRUD endpoints for clients and users
- Ensure role-based access control: only admins can manage clients

---

## Data and security details

- **PasswordHasher:** use per-user salt, versioned hashing; rehash on sign-in if outdated.
- **Refresh token rotation:** store token family; on use, issue new and mark old as used; detect reuse to revoke entire family.
- **AuditLog:** record token issuance, consent events, revoke actions; include IP, user_id, client_id.
- **Scopes registry:** centralized list with descriptions; ensure controllers validate allowed scopes per client.

---

## Example payloads

#### Authorization request (SPA)
- GET /connect/authorize?client_id=shop_spa&redirect_uri=https://app/callback&response_type=code&scope=openid%20profile%20offline_access&state=xyz&code_challenge=...&code_challenge_method=S256

#### Token exchange (PKCE)
- POST /connect/token
  - grant_type=authorization_code
  - code=...
  - client_id=shop_spa
  - redirect_uri=https://app/callback
  - code_verifier=...

#### Client credentials
- POST /connect/token
  - grant_type=client_credentials
  - client_id=jobs_service
  - client_secret=...

#### Refresh
- POST /connect/token
  - grant_type=refresh_token
  - refresh_token=...

#### Revoke
- POST /connect/revoke
  - token=...
  - token_type_hint=refresh_token

---

## Seeding and policy

- Seed two clients:
  - **shop_spa**: public, authorization_code + PKCE, scopes: openid, profile, offline_access, products.read
  - **jobs_service**: confidential, client_credentials, scopes: audit.write, products.read
- Seed roles and users:
  - admin@example.com → roles: Admin
  - user@example.com → roles: User
- Seed consents:
  - user → shop_spa → openid, profile
- Enforce:
  - Public clients must not have secrets.
  - Confidential clients must have hashed secrets and allowed grants.

---

## Commit message

```
feat(auth): add full OpenId flow with PKCE, client credentials, refresh, revoke, and consent

- Enabled Authorization Code + PKCE for public clients and Client Credentials for confidential clients
- Implemented refresh token rotation and revoke endpoint handling
- Added consent model and UI flow; persisted user-client scope grants
- Secured client secrets with hashing and enforced grant/scopes policies
- Extended AuthorizationController for authorize/token/revoke/userinfo
- Seeded clients, users, roles, and baseline consents
- Updated OpenIddict server configuration and validation events
- Enhanced audit logging for token issuance and revocation
```

İstersen bu akış için Swagger’daki “Authorize” butonunu da yapılandırıp client credentials ve userinfo testlerini dokümante edeyim. Ayrıca frontend SPA için PKCE helper ve consent modal komponeni çıkartabilirim.